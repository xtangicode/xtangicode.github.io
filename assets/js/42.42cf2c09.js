(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{460:function(t,a,s){"use strict";s.r(a);var r=s(14),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"索引-index"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引-index"}},[t._v("#")]),t._v(" 索引 (Index）")]),t._v(" "),a("p",[t._v("一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识(必须全部是小写字母)，并且当我们要对这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。")]),t._v(" "),a("h2",{attrs:{id:"类型-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型-type"}},[t._v("#")]),t._v(" 类型(Type)")]),t._v(" "),a("p",[t._v("在一个索引中，你可以定义一种或多种类型\n一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("版本")]),t._v(" "),a("th",[t._v("Type")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("5.x")]),t._v(" "),a("td",[t._v("支持多种type")])]),t._v(" "),a("tr",[a("td",[t._v("6.x")]),t._v(" "),a("td",[t._v("只能有一种type")])]),t._v(" "),a("tr",[a("td",[t._v("7.x")]),t._v(" "),a("td",[t._v("默认不再支持自定义索引类型 (默认类型为: _doc)")])])])]),t._v(" "),a("h2",{attrs:{id:"文档-document"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文档-document"}},[t._v("#")]),t._v(" 文档(Document)")]),t._v(" "),a("p",[t._v("一个文档是一个可被索引的基础信息单元，也就是一条数据比如:你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON (Javascript Object Notation) 格式来表示，而JSON 是一个到处存在的互联网数据交互格式。\n在一个 index/type 里面，你可以存储任意多的文档。")]),t._v(" "),a("h2",{attrs:{id:"字段-field"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字段-field"}},[t._v("#")]),t._v(" 字段 (Field)")]),t._v(" "),a("p",[t._v("相当于是数据表的字段，对文档数据根据不同属性进行的分类标识.")]),t._v(" "),a("h2",{attrs:{id:"映射-mapping"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#映射-mapping"}},[t._v("#")]),t._v(" 映射(Mapping)")]),t._v(" "),a("p",[t._v("mapping 是处理数据的方式和规则方面做一些限制，如: 某个字段的数据类型、默认值.分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一些使用规则设置也叫做映射,按着最优规则处理数据对性能提高很大,因此才需要建立映射,并且需要思考如何建立映射才能对性能更好。")]),t._v(" "),a("h2",{attrs:{id:"分片-shards"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分片-shards"}},[t._v("#")]),t._v(" 分片(Shards)")]),t._v(" "),a("p",[t._v("一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有 10 亿文档数据的索引占据 1TB 的磁盘空间，而任一节点都可能没有这样大的磁盘空间。或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch 提供了将索引划分成多份的能力,每一份就称之为分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点\n分片很重要，主要有两方面的原因:")]),t._v(" "),a("ol",[a("li",[t._v("允许你水平分割 / 扩展你的内容容量。")]),t._v(" "),a("li",[t._v("允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。至于一个分片怎样分布，它的文档怎样聚合和搜索请求,是完全由 Elasticsearch 管理的,对于作为用户的你来说，这些都是透明的，无需过分关心。")])]),t._v(" "),a("h2",{attrs:{id:"副本-replicas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副本-replicas"}},[t._v("#")]),t._v(" 副本(Replicas）")]),t._v(" "),a("p",[t._v("在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elastisearch 允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。")]),t._v(" "),a("p",[t._v("复制分片之所以重要，有两个主要原因:")]),t._v(" "),a("ul",[a("li",[t._v("在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要 (original/primary) 分片置于同一节点上是非常重要的。")]),t._v(" "),a("li",[t._v("扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。")])]),t._v(" "),a("h2",{attrs:{id:"分配-ailocation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分配-ailocation"}},[t._v("#")]),t._v(" 分配 (AIlocation )")]),t._v(" "),a("p",[t._v("将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由 master 节点完成的。")])])}),[],!1,null,null,null);a.default=v.exports}}]);